package net.vulkanmod.vulkan.shader;

public class ShaderArchitype
{
    ConPositeStages compositeStage;

    //idnentify overallping reagions,a nd elmitate and sutine overallping reducndnaices into an aggerated verabel self-transforing "Shader Architype", ehich adapts istelf based on teh sepcif cchanges ans and when required, , ensuring no overlap or redcucnaes occur or take place and tehfore nay ratwed repated or refertcifnreudnat work/(ie swatsred works ) and that no work of stages.pahes are wstesddd arw wated at and gieve dkidbed
//Elimiate Dpendies of exqutive , and ensure fl;alcite Out of Outder Execution at all times of an at all viable at andt patcia;et time
    i.e. to avoid unnCERy chaining.stalls, pipeliening.statls and or barred dkcheiodebsjdhdkensismdusidnm

    //negated stages...
//TOOD; EXECUTionDpencies, execution
//    e.g. rendeirng terrain and Water and the same time simulatneousl;y, as mper mroe clos;ey isif pmroe cplsoeold;papxonting to vanilal behavuipir e.g.
    public ShaderArchitype(ShaderUtil.ShaderStage[] shaderStage, RenderStateShades neededStagesAccess, ShaderComponant shaderComponant, ) {
//    i/e. Also a bit like the comopsite ALyer syteme used currently for rendrlayers/-Compiste layers e.g.blic ShaderArchitype(neededStages, ) {

        //StageComponats.stages are dybam ical consituted from the various stages, based the onteh vien need, pruspeo, function and consitage.dpendied sistuatiooens of the Variosu Shaders imepe,msts e..fi.e.i.e..etc .msic l.e.c i.ek/stc
        //Optimising ShaderStage ->subsutive elmitaion
        this.compositeStage = compositeStage;
    }
}
